/*
题目描述
2060年是云南中医学院的百年校庆，于是学生会的同学们搞了一个连续猜谜活动：共有10个谜题，现在告诉所有人第一个谜题，每个谜题的答案就是下一个谜题的线索....成功破解最后一个谜题后，答案就是指向奖励的线索
在所有同学们的努力下，全校同学们获得了最后一个谜题，这个谜题有几十张纸，上面全是密密麻麻的数字以及'.'
第一页内容如下：
1,2,3,4,5,6
4,1,5,2,6,3
2,4,6,1,3,5
1,2,3,4,5,6
———3

1,2,3,4....32
.............
.............
———10

有细心的同学发现，这是对一组1-2n的序列进行如下移动：每次将前n个数字取出，按顺序依次插入到位于n+1,n+2...2n的数字后面，最后的数字表示多少次移动后会变回原来的序列
第二页内容如下：
1,2,3,4....64
.............
.............
———?

1,2,3,4....140
.............
.............
———?

同学们发现，越往后翻，这个序列的长度就越长，前面十几二十个数字的序列同学们还可以一步一步模拟做出来，但是到后来几千甚至上万的长度，就没有办法计算了，甚至中间一步做错，就步步都错。
这个谜题真是太过分了！但是奖励就在眼前，只要计算出所有答案，所有答案就是指引同学们获得奖励的线索，那么现在问题来了，同学们除了发现上面的n=最后那个数字/2之外，没有办法给你任何帮助，而作为一个计算机科学与技术专业的大佬，你自然就成为了同学们心目中拯救他们的英雄，所以你能不能写一个程序，当你知道n是多少的时候，可以直接得出答案呢？

输入
多组测试数据.每组数据的第一行包含一个正整数n(1<= n<=10000).

输出
每组数据输出一行整数表示最少需要经过几次移动能变回原序列，若不能，则输出"-1"

样例输入 Copy
3
16
样例输出 Copy
3
10
*/

/*
通过题目，推导规律.
我们可以根据1所在的位置判断出还需要进行几步到达第一位，当1恢复原位后，会发现其他数也恢复原位，
因此可以知道在经过num步后，当1到达n+1位置时，则还需要1步恢复原位，
当1所在位置小于等于n，那么pos += pos, ans++;
大于n，则pos -= 2 * n - pos + 1, ans++;
此题不存在-1的情况
*/
#include <bits/stdc++.h>
using namespace std;
int get(int n)
{
    //pos表示1的位置，此处pos+1，ans+1 表示已经执行一次的结果，加速计算
    int pos = 2;
    int ans = 1;

    while (pos != 1)
    {
        //cout<<"S:"<<pos<<endl;
        if (pos <= n)
            pos += pos, ans++;
        else
            pos -= 2 * n - pos + 1, ans++;
        //cout<<"E:"<<pos<<endl;
    }
    return ans;
}
int main()
{
    int n;
    while (scanf("%d", &n) != EOF)
    {
        printf("%d\n", get(n));
    }
    return 0;
}